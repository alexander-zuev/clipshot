#!/usr/bin/env bash
set -euo pipefail

VERSION="0.2.0"
SCREENSHOTS_DIR="$HOME/.screenshots"
LATEST="$SCREENSHOTS_DIR/latest.png"
MAX="${CLIPSHOT_MAX:-50}"
SHARE_DIR="$HOME/.local/share/clipshot"
BIN_DIR="$HOME/.local/bin"
SERVICE_DIR="$HOME/.config/systemd/user"
PIDFILE="$SHARE_DIR/clipshot.pid"
REPO_DIR="$(cd "$(dirname "$0")" && pwd)"

# Resolve powershell.exe ‚Äî systemd services lack WSL interop PATH
find_powershell() {
    local ps
    ps=$(command -v powershell.exe 2>/dev/null) && [ -x "$ps" ] && { echo "$ps"; return; }
    for p in /mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe \
             /mnt/c/WINDOWS/System32/WindowsPowerShell/v1.0/powershell.exe; do
        [ -x "$p" ] && { echo "$p"; return; }
    done
    echo "clipshot: powershell.exe not found ‚Äî is WSL interop enabled?" >&2
    return 1
}

# Convert WSL home to Windows UNC path for PowerShell
win_save_path() {
    wslpath -w "$SCREENSHOTS_DIR"
}

cleanup_old() {
    local keep="${1:-$MAX}"
    find "$SCREENSHOTS_DIR" -maxdepth 1 -name 'screenshot_*.png' -printf '%T@\t%p\0' 2>/dev/null \
        | sort -zrn \
        | while IFS=$'\t' read -r -d '' _ts path; do
            keep=$((keep - 1))
            [ "$keep" -lt 0 ] && rm -f -- "$path"
        done
}

cmd_run() {
    # Prevent duplicate instances
    if [ -f "$PIDFILE" ] && kill -0 "$(cat "$PIDFILE")" 2>/dev/null; then
        echo "clipshot: already running (pid $(cat "$PIDFILE"))" >&2
        return 1
    fi
    mkdir -p "$SCREENSHOTS_DIR" "$SHARE_DIR"
    echo $$ > "$PIDFILE"
    trap 'rm -f "$PIDFILE"' EXIT INT TERM

    local wpath
    wpath=$(win_save_path)

    local ps
    ps=$(find_powershell)

    "$ps" -NoProfile -NonInteractive -ExecutionPolicy Bypass \
        -File "$SHARE_DIR/watcher.ps1" -SavePath "$wpath" 2>&1 |
    while IFS= read -r line; do
        line="${line%%$'\r'}"  # strip CR from Windows output
        case "$line" in
            READY)
                echo "üëÄ Watching clipboard for screenshots..." >&2 ;;
            SAVED:*)
                local name="${line#SAVED:}"
                local file="$SCREENSHOTS_DIR/$name"
                # Wait briefly for file to appear via UNC mount
                for _ in 1 2 3 4 5; do [ -f "$file" ] && break; sleep 0.2; done
                if [ -f "$file" ]; then
                    ln -sf "$file" "$LATEST"
                    echo "üì∏ $name" >&2
                    cleanup_old "$MAX"
                else
                    echo "‚ö†Ô∏è  File not found after save: $name" >&2
                fi
                ;;
            ERROR:*)
                echo "‚ùå ${line#ERROR:}" >&2 ;;
            *)
                ;;  # ignore noise
        esac
    done
}

cmd_install() {
    echo "üì¶ Installing clipshot..."
    mkdir -p "$BIN_DIR" "$SHARE_DIR" "$SERVICE_DIR" "$SCREENSHOTS_DIR"
    cp "$REPO_DIR/clipshot" "$BIN_DIR/clipshot"
    chmod +x "$BIN_DIR/clipshot"
    cp "$REPO_DIR/watcher.ps1" "$SHARE_DIR/watcher.ps1"
    cp "$REPO_DIR/clipshot.service" "$SERVICE_DIR/clipshot.service"
    systemctl --user daemon-reload
    systemctl --user enable clipshot.service
    echo "‚úÖ Installed. Run: clipshot start"
}

cmd_uninstall() {
    echo "üóëÔ∏è  Uninstalling clipshot..."
    systemctl --user stop clipshot.service 2>/dev/null || true
    systemctl --user disable clipshot.service 2>/dev/null || true
    rm -f "$BIN_DIR/clipshot"
    rm -rf "$SHARE_DIR"
    rm -f "$SERVICE_DIR/clipshot.service"
    systemctl --user daemon-reload
    echo "‚úÖ Removed. Screenshots in $SCREENSHOTS_DIR preserved."
}

cmd_status() {
    local state
    state=$(systemctl --user is-active clipshot.service 2>/dev/null || echo "inactive")
    local count
    count=$(find "$SCREENSHOTS_DIR" -maxdepth 1 -name 'screenshot_*.png' 2>/dev/null | wc -l)
    local size
    size=$(du -sh "$SCREENSHOTS_DIR" 2>/dev/null | cut -f1 || echo "0")
    local latest_name="-"
    [ -L "$LATEST" ] && latest_name=$(basename "$(readlink "$LATEST")" 2>/dev/null || echo "-")

    echo "Service:      $state"
    echo "Screenshots:  $count files ($size)"
    echo "Latest:       $latest_name"
    echo "Max kept:     $MAX"
}

cmd_latest() {
    if [ -L "$LATEST" ] && [ -f "$LATEST" ]; then
        readlink -f "$LATEST"
    else
        echo "No screenshots yet" >&2
        return 1
    fi
}

cmd_clean() {
    local keep="${1:-$MAX}"
    local before
    before=$(find "$SCREENSHOTS_DIR" -maxdepth 1 -name 'screenshot_*.png' 2>/dev/null | wc -l)
    cleanup_old "$keep"
    local after
    after=$(find "$SCREENSHOTS_DIR" -maxdepth 1 -name 'screenshot_*.png' 2>/dev/null | wc -l)
    echo "Cleaned: $((before - after)) removed, $after remaining"
}

cmd_help() {
    cat <<'EOF'
clipshot ‚Äî WSL2 screenshot bridge

Usage: clipshot <command>

Commands:
  install       Install clipshot and enable systemd service
  uninstall     Remove all installed files (keeps screenshots)
  start         Start the service
  stop          Stop the service
  status        Show service state, screenshot count, disk usage
  logs          Follow service logs (journalctl)
  latest        Print path to most recent screenshot
  clean [N]     Keep N most recent screenshots (default: 50)
  version       Print version
  run           Run in foreground (used by systemd)

Environment:
  CLIPSHOT_MAX  Max screenshots to keep (default: 50)
EOF
}

cmd_start() {
    systemctl --user start clipshot.service
    echo "‚úÖ Started. Take a screenshot with Win+Shift+S"
    echo "   View logs: clipshot logs"
}

cmd_stop() {
    systemctl --user stop clipshot.service
    echo "‚èπÔ∏è  Stopped."
}

case "${1:-}" in
    run)        cmd_run ;;
    version)    echo "clipshot $VERSION" ;;
    install)    cmd_install ;;
    uninstall)  cmd_uninstall ;;
    start)      cmd_start ;;
    stop)       cmd_stop ;;
    status)     cmd_status ;;
    logs)       journalctl --user -u clipshot -f ;;
    latest)     cmd_latest ;;
    clean)      cmd_clean "${2:-}" ;;
    *)          cmd_help ;;
esac
